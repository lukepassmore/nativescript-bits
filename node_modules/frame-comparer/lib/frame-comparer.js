"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const ffmpeg = require("fluent-ffmpeg");
const blinkDiff = require("blink-diff");
const path_1 = require("path");
const fs_1 = require("fs");
class FrameComparer {
    compareImageFromVideo(expectedImageFullName, logStorage, startRange, endRange, tollerance = 0.2, saveActualImageAsExpected = true, shouldLogImageResults = false, cropImageRect = undefined, verbose = true) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!saveActualImageAsExpected && !fs_1.existsSync(expectedImageFullName)) {
                throw new Error(`${expectedImageFullName} is not available!!!`);
            }
            return new Promise((accept, reject) => __awaiter(this, void 0, void 0, function* () {
                endRange = endRange < this._frames.length ? endRange : this._frames.length;
                const filteredFrames = this._frames.filter(f => {
                    const number = f.replace(/\D/g, "");
                    if (number >= startRange && number <= endRange) {
                        return true;
                    }
                    return false;
                });
                let isExcpectedImageAvailable = true;
                for (let index = 0; index < filteredFrames.length; index++) {
                    if (verbose) {
                        console.log(filteredFrames[index]);
                    }
                    isExcpectedImageAvailable = fs_1.existsSync(expectedImageFullName);
                    const extn = path_1.extname(filteredFrames[index]);
                    const getFrameIndex = (fileName, extn) => /\d+/.exec(new RegExp(`\\d+` + extn).exec(fileName)[0])[0];
                    const desiredFrame = getFrameIndex(expectedImageFullName, extn);
                    const currentFrame = getFrameIndex(filteredFrames[index], extn);
                    if (saveActualImageAsExpected && !isExcpectedImageAvailable && desiredFrame === currentFrame) {
                        fs_1.writeFileSync(expectedImageFullName, fs_1.readFileSync(filteredFrames[index]));
                        isExcpectedImageAvailable = true;
                    }
                    if (isExcpectedImageAvailable) {
                        const diffImage = (!shouldLogImageResults || !logStorage) ? undefined : path_1.resolve(logStorage, path_1.basename(filteredFrames[index].replace(extn, `_diff${extn}`)));
                        const result = yield this.compareImages(filteredFrames[index], expectedImageFullName, diffImage, tollerance, blinkDiff.THRESHOLD_PERCENT, cropImageRect, verbose);
                        if (result) {
                            return accept(true);
                        }
                    }
                }
                return accept(false);
            }));
        });
    }
    processVideo(fullVideoName, frameStorageFullName = "tempFramesFolder", framesGeneralName = "frame") {
        this._frameStorageFullName = frameStorageFullName;
        this.cleanDir(this._frameStorageFullName);
        fs_1.mkdirSync(this._frameStorageFullName);
        let lastFrameEnqueued = 0;
        const sorage = this._frameStorageFullName;
        const that = this;
        const imageName = path_1.resolve(this._frameStorageFullName, framesGeneralName);
        return new Promise((res, reject) => {
            ffmpeg(fullVideoName)
                .on('error', function (err) {
                console.log('An error occurred: ' + err.message);
                reject();
            })
                .on('end', function () {
                that._frames = new Array();
                console.log('Processing finished !');
                fs_1.readdirSync(sorage)
                    .forEach((file) => {
                    file = path_1.resolve(sorage, file);
                    that._frames.push(file);
                });
                res();
            })
                .on('progress', function (progress) {
                lastFrameEnqueued = progress.frames - 1;
                for (let n = lastFrameEnqueued + 1; n < progress.frames; n++) {
                    console.log(n);
                }
            })
                .save(`${imageName}%d.png`);
        });
    }
    compareImages(actual, expected, output, valueThreshold = 0.01, typeThreshold, cropImageRect, verbose = true) {
        return __awaiter(this, void 0, void 0, function* () {
            const diff = new blinkDiff({
                imageAPath: actual,
                cropImageA: cropImageRect,
                imageBPath: expected,
                cropImageB: cropImageRect,
                imageOutputPath: output,
                imageOutputLimit: blinkDiff.OUTPUT_ALL,
                thresholdType: typeThreshold,
                threshold: valueThreshold,
                delta: 20,
            });
            return yield this.runDiff(diff, verbose);
        });
    }
    runDiff(diffOptions, verbose) {
        return new Promise((resolve, reject) => {
            diffOptions.run(function (error, result) {
                if (error) {
                    throw error;
                }
                else {
                    let message;
                    let resultCode = diffOptions.hasPassed(result.code);
                    if (resultCode) {
                        if (verbose) {
                            message = "Screen compare passed!";
                            console.log(message);
                            console.log('Found ' + result.differences + ' differences.');
                        }
                        return resolve(true);
                    }
                    else {
                        if (verbose) {
                            message = "Screen compare failed!";
                            console.log(message);
                            console.log('Found ' + result.differences + ' differences.');
                        }
                        return resolve(false);
                    }
                }
            });
        });
    }
    cleanDir(dirFullName) {
        if (fs_1.existsSync(dirFullName)) {
            const pathToFile = dirFullName;
            fs_1.readdirSync(dirFullName)
                .forEach(file => {
                const f = path_1.resolve(pathToFile, file);
                if (this.isDirectory(f)) {
                    this.cleanDir(f);
                }
                fs_1.unlinkSync(f);
            });
            fs_1.rmdirSync(dirFullName);
        }
    }
    isDirectory(fullName) {
        try {
            if (fs_1.existsSync(fullName) && fs_1.statSync(fullName).isDirectory()) {
                return true;
            }
        }
        catch (e) {
            return false;
        }
        return false;
    }
}
exports.FrameComparer = FrameComparer;
//# sourceMappingURL=frame-comparer.js.map