"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("./utils");
const frComparer = require("frame-comparer");
const image_helper_1 = require("./image-helper");
function loadFrameComparer(nsCapabilities) {
    try {
        const frameComparer = frComparer.createFrameComparer();
        const storage = utils_1.getStorageByDeviceName(nsCapabilities);
        const logPath = utils_1.getReportPath(nsCapabilities);
        return new FrameComparer(nsCapabilities, storage, logPath, frameComparer);
    }
    catch (error) {
        console.error("In order to use frame comaprer, please read carefully https://github.com/SvetoslavTsenov/frame-comparer/blob/master/README.md for dependecies that are required!");
    }
}
exports.loadFrameComparer = loadFrameComparer;
class FrameComparer {
    constructor(_nsCapabilities, _storage, _logPath, _frameComparer) {
        this._nsCapabilities = _nsCapabilities;
        this._storage = _storage;
        this._logPath = _logPath;
        this._frameComparer = _frameComparer;
        this._framesGeneralName = "frame";
        this._cropImageRect = image_helper_1.ImageHelper.cropImageDefault(this._nsCapabilities);
    }
    processVideo(videoFullName, framesGeneralName, videoTempStorage = "tempFramesFolder") {
        return __awaiter(this, void 0, void 0, function* () {
            this._framesGeneralName = framesGeneralName || this._framesGeneralName;
            this._framesGeneralName = this._framesGeneralName.replace(/\s/gi, "");
            yield this._frameComparer.processVideo(videoFullName, videoTempStorage, this._framesGeneralName);
        });
    }
    compareFrameRanges(imageFrameCount, startRange, endRange, logImageComparisonResults = false, tollerancePixels = 0.1, verbose = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this._frameComparer.compareImageFromVideo(utils_1.resolve(this._storage, `${this._framesGeneralName}${imageFrameCount}.png`), this._logPath, startRange, endRange, tollerancePixels, this._cropImageRect, true, logImageComparisonResults, verbose);
            return result;
        });
    }
    compareFrames(imageFrameCount, tolleranceRange = 3, tollerancePixels = 0.1, logImageComparisonResults = false, verbose = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const start = imageFrameCount - tolleranceRange > 0 ? imageFrameCount - tolleranceRange : 0;
            const end = imageFrameCount + tolleranceRange;
            const result = yield this.compareFrameRanges(imageFrameCount, start, end, logImageComparisonResults, tollerancePixels);
            return result;
        });
    }
}
exports.FrameComparer = FrameComparer;
//# sourceMappingURL=frame-comparer.js.map